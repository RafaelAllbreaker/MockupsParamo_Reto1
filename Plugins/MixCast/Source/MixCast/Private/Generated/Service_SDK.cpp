/**
 * Autogenerated by Thrift Compiler (Shiyao Modified base on 0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Service_SDK.h"

namespace mixcast { namespace thrift {


Service_SDK_validate_ping_args::~Service_SDK_validate_ping_args() throw() {
}


uint32_t Service_SDK_validate_ping_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Service_SDK_validate_ping_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Service_SDK_validate_ping_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Service_SDK_validate_ping_pargs::~Service_SDK_validate_ping_pargs() throw() {
}


uint32_t Service_SDK_validate_ping_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Service_SDK_validate_ping_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Service_SDK_validate_ping_result::~Service_SDK_validate_ping_result() throw() {
}


uint32_t Service_SDK_validate_ping_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Service_SDK_validate_ping_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Service_SDK_validate_ping_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Service_SDK_validate_ping_presult::~Service_SDK_validate_ping_presult() throw() {
}


uint32_t Service_SDK_validate_ping_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Service_SDK_validate_function_list_args::~Service_SDK_validate_function_list_args() throw() {
}


uint32_t Service_SDK_validate_function_list_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Service_SDK_validate_function_list_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Service_SDK_validate_function_list_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Service_SDK_validate_function_list_pargs::~Service_SDK_validate_function_list_pargs() throw() {
}


uint32_t Service_SDK_validate_function_list_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Service_SDK_validate_function_list_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Service_SDK_validate_function_list_result::~Service_SDK_validate_function_list_result() throw() {
}


uint32_t Service_SDK_validate_function_list_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->success.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += iprot->readString(this->success[_i4]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Service_SDK_validate_function_list_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("Service_SDK_validate_function_list_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->success.size()));
      std::vector<std::string> ::const_iterator _iter5;
      for (_iter5 = this->success.begin(); _iter5 != this->success.end(); ++_iter5)
      {
        xfer += oprot->writeString((*_iter5));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Service_SDK_validate_function_list_presult::~Service_SDK_validate_function_list_presult() throw() {
}


uint32_t Service_SDK_validate_function_list_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            xfer += iprot->readListBegin(_etype9, _size6);
            (*(this->success)).resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += iprot->readString((*(this->success))[_i10]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


Service_SDK_SetActivationState_args::~Service_SDK_SetActivationState_args() throw() {
}


uint32_t Service_SDK_SetActivationState_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->active);
          this->__isset.active = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Service_SDK_SetActivationState_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Service_SDK_SetActivationState_args");

  xfer += oprot->writeFieldBegin("active", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->active);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Service_SDK_SetActivationState_pargs::~Service_SDK_SetActivationState_pargs() throw() {
}


uint32_t Service_SDK_SetActivationState_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Service_SDK_SetActivationState_pargs");

  xfer += oprot->writeFieldBegin("active", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool((*(this->active)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Service_SDK_NotifyServiceStarted_args::~Service_SDK_NotifyServiceStarted_args() throw() {
}


uint32_t Service_SDK_NotifyServiceStarted_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Service_SDK_NotifyServiceStarted_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Service_SDK_NotifyServiceStarted_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Service_SDK_NotifyServiceStarted_pargs::~Service_SDK_NotifyServiceStarted_pargs() throw() {
}


uint32_t Service_SDK_NotifyServiceStarted_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Service_SDK_NotifyServiceStarted_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Service_SDK_SendLegacyData_args::~Service_SDK_SendLegacyData_args() throw() {
}


uint32_t Service_SDK_SendLegacyData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dataJson);
          this->__isset.dataJson = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Service_SDK_SendLegacyData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Service_SDK_SendLegacyData_args");

  xfer += oprot->writeFieldBegin("dataJson", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dataJson);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Service_SDK_SendLegacyData_pargs::~Service_SDK_SendLegacyData_pargs() throw() {
}


uint32_t Service_SDK_SendLegacyData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Service_SDK_SendLegacyData_pargs");

  xfer += oprot->writeFieldBegin("dataJson", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->dataJson)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Service_SDK_UpdateTrackedObjectMetadata_args::~Service_SDK_UpdateTrackedObjectMetadata_args() throw() {
}


uint32_t Service_SDK_UpdateTrackedObjectMetadata_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->trackedObjects.clear();
            uint32_t _size11;
            ::apache::thrift::protocol::TType _etype14;
            xfer += iprot->readListBegin(_etype14, _size11);
            this->trackedObjects.resize(_size11);
            uint32_t _i15;
            for (_i15 = 0; _i15 < _size11; ++_i15)
            {
              xfer += this->trackedObjects[_i15].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.trackedObjects = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Service_SDK_UpdateTrackedObjectMetadata_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Service_SDK_UpdateTrackedObjectMetadata_args");

  xfer += oprot->writeFieldBegin("trackedObjects", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->trackedObjects.size()));
    std::vector< ::mixcast::data::TrackedObject> ::const_iterator _iter16;
    for (_iter16 = this->trackedObjects.begin(); _iter16 != this->trackedObjects.end(); ++_iter16)
    {
      xfer += (*_iter16).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Service_SDK_UpdateTrackedObjectMetadata_pargs::~Service_SDK_UpdateTrackedObjectMetadata_pargs() throw() {
}


uint32_t Service_SDK_UpdateTrackedObjectMetadata_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Service_SDK_UpdateTrackedObjectMetadata_pargs");

  xfer += oprot->writeFieldBegin("trackedObjects", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->trackedObjects)).size()));
    std::vector< ::mixcast::data::TrackedObject> ::const_iterator _iter17;
    for (_iter17 = (*(this->trackedObjects)).begin(); _iter17 != (*(this->trackedObjects)).end(); ++_iter17)
    {
      xfer += (*_iter17).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Service_SDK_UpdateCameraMetadata_args::~Service_SDK_UpdateCameraMetadata_args() throw() {
}


uint32_t Service_SDK_UpdateCameraMetadata_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cameras.clear();
            uint32_t _size18;
            ::apache::thrift::protocol::TType _etype21;
            xfer += iprot->readListBegin(_etype21, _size18);
            this->cameras.resize(_size18);
            uint32_t _i22;
            for (_i22 = 0; _i22 < _size18; ++_i22)
            {
              xfer += this->cameras[_i22].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cameras = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Service_SDK_UpdateCameraMetadata_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Service_SDK_UpdateCameraMetadata_args");

  xfer += oprot->writeFieldBegin("cameras", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->cameras.size()));
    std::vector< ::mixcast::data::VirtualCamera> ::const_iterator _iter23;
    for (_iter23 = this->cameras.begin(); _iter23 != this->cameras.end(); ++_iter23)
    {
      xfer += (*_iter23).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Service_SDK_UpdateCameraMetadata_pargs::~Service_SDK_UpdateCameraMetadata_pargs() throw() {
}


uint32_t Service_SDK_UpdateCameraMetadata_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Service_SDK_UpdateCameraMetadata_pargs");

  xfer += oprot->writeFieldBegin("cameras", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->cameras)).size()));
    std::vector< ::mixcast::data::VirtualCamera> ::const_iterator _iter24;
    for (_iter24 = (*(this->cameras)).begin(); _iter24 != (*(this->cameras)).end(); ++_iter24)
    {
      xfer += (*_iter24).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Service_SDK_UpdateViewfinderMetadata_args::~Service_SDK_UpdateViewfinderMetadata_args() throw() {
}


uint32_t Service_SDK_UpdateViewfinderMetadata_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->viewfinders.clear();
            uint32_t _size25;
            ::apache::thrift::protocol::TType _etype28;
            xfer += iprot->readListBegin(_etype28, _size25);
            this->viewfinders.resize(_size25);
            uint32_t _i29;
            for (_i29 = 0; _i29 < _size25; ++_i29)
            {
              xfer += this->viewfinders[_i29].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.viewfinders = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Service_SDK_UpdateViewfinderMetadata_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Service_SDK_UpdateViewfinderMetadata_args");

  xfer += oprot->writeFieldBegin("viewfinders", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->viewfinders.size()));
    std::vector< ::mixcast::data::Viewfinder> ::const_iterator _iter30;
    for (_iter30 = this->viewfinders.begin(); _iter30 != this->viewfinders.end(); ++_iter30)
    {
      xfer += (*_iter30).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Service_SDK_UpdateViewfinderMetadata_pargs::~Service_SDK_UpdateViewfinderMetadata_pargs() throw() {
}


uint32_t Service_SDK_UpdateViewfinderMetadata_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Service_SDK_UpdateViewfinderMetadata_pargs");

  xfer += oprot->writeFieldBegin("viewfinders", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->viewfinders)).size()));
    std::vector< ::mixcast::data::Viewfinder> ::const_iterator _iter31;
    for (_iter31 = (*(this->viewfinders)).begin(); _iter31 != (*(this->viewfinders)).end(); ++_iter31)
    {
      xfer += (*_iter31).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Service_SDK_UpdateDesktopMetadata_args::~Service_SDK_UpdateDesktopMetadata_args() throw() {
}


uint32_t Service_SDK_UpdateDesktopMetadata_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->desktop.read(iprot);
          this->__isset.desktop = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Service_SDK_UpdateDesktopMetadata_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Service_SDK_UpdateDesktopMetadata_args");

  xfer += oprot->writeFieldBegin("desktop", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->desktop.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Service_SDK_UpdateDesktopMetadata_pargs::~Service_SDK_UpdateDesktopMetadata_pargs() throw() {
}


uint32_t Service_SDK_UpdateDesktopMetadata_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Service_SDK_UpdateDesktopMetadata_pargs");

  xfer += oprot->writeFieldBegin("desktop", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->desktop)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Service_SDK_NotifyExternalTexturesUpdated_args::~Service_SDK_NotifyExternalTexturesUpdated_args() throw() {
}


uint32_t Service_SDK_NotifyExternalTexturesUpdated_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->textureInfo.clear();
            uint32_t _size32;
            ::apache::thrift::protocol::TType _etype35;
            xfer += iprot->readListBegin(_etype35, _size32);
            this->textureInfo.resize(_size32);
            uint32_t _i36;
            for (_i36 = 0; _i36 < _size32; ++_i36)
            {
              xfer += this->textureInfo[_i36].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.textureInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Service_SDK_NotifyExternalTexturesUpdated_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Service_SDK_NotifyExternalTexturesUpdated_args");

  xfer += oprot->writeFieldBegin("textureInfo", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->textureInfo.size()));
    std::vector< ::mixcast::thrift::SharedTexPacket> ::const_iterator _iter37;
    for (_iter37 = this->textureInfo.begin(); _iter37 != this->textureInfo.end(); ++_iter37)
    {
      xfer += (*_iter37).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Service_SDK_NotifyExternalTexturesUpdated_pargs::~Service_SDK_NotifyExternalTexturesUpdated_pargs() throw() {
}


uint32_t Service_SDK_NotifyExternalTexturesUpdated_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Service_SDK_NotifyExternalTexturesUpdated_pargs");

  xfer += oprot->writeFieldBegin("textureInfo", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->textureInfo)).size()));
    std::vector< ::mixcast::thrift::SharedTexPacket> ::const_iterator _iter38;
    for (_iter38 = (*(this->textureInfo)).begin(); _iter38 != (*(this->textureInfo)).end(); ++_iter38)
    {
      xfer += (*_iter38).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Service_SDK_ResetWorldOrientation_args::~Service_SDK_ResetWorldOrientation_args() throw() {
}


uint32_t Service_SDK_ResetWorldOrientation_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Service_SDK_ResetWorldOrientation_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Service_SDK_ResetWorldOrientation_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Service_SDK_ResetWorldOrientation_pargs::~Service_SDK_ResetWorldOrientation_pargs() throw() {
}


uint32_t Service_SDK_ResetWorldOrientation_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Service_SDK_ResetWorldOrientation_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Service_SDK_ModifyWorldOrientation_args::~Service_SDK_ModifyWorldOrientation_args() throw() {
}


uint32_t Service_SDK_ModifyWorldOrientation_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->degrees);
          this->__isset.degrees = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Service_SDK_ModifyWorldOrientation_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Service_SDK_ModifyWorldOrientation_args");

  xfer += oprot->writeFieldBegin("degrees", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->degrees);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Service_SDK_ModifyWorldOrientation_pargs::~Service_SDK_ModifyWorldOrientation_pargs() throw() {
}


uint32_t Service_SDK_ModifyWorldOrientation_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Service_SDK_ModifyWorldOrientation_pargs");

  xfer += oprot->writeFieldBegin("degrees", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble((*(this->degrees)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Service_SDK_SendExperienceCommand_args::~Service_SDK_SendExperienceCommand_args() throw() {
}


uint32_t Service_SDK_SendExperienceCommand_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cmdId);
          this->__isset.cmdId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Service_SDK_SendExperienceCommand_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Service_SDK_SendExperienceCommand_args");

  xfer += oprot->writeFieldBegin("cmdId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->cmdId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


Service_SDK_SendExperienceCommand_pargs::~Service_SDK_SendExperienceCommand_pargs() throw() {
}


uint32_t Service_SDK_SendExperienceCommand_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Service_SDK_SendExperienceCommand_pargs");

  xfer += oprot->writeFieldBegin("cmdId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->cmdId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void Service_SDKClient::validate_ping()
{
  send_validate_ping();
  recv_validate_ping();
}

void Service_SDKClient::send_validate_ping()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("validate_ping", ::apache::thrift::protocol::T_CALL, cseqid);

  Service_SDK_validate_ping_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void Service_SDKClient::recv_validate_ping()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("validate_ping") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Service_SDK_validate_ping_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void Service_SDKClient::validate_function_list(std::vector<std::string> & _return)
{
  send_validate_function_list();
  recv_validate_function_list(_return);
}

void Service_SDKClient::send_validate_function_list()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("validate_function_list", ::apache::thrift::protocol::T_CALL, cseqid);

  Service_SDK_validate_function_list_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void Service_SDKClient::recv_validate_function_list(std::vector<std::string> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("validate_function_list") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  Service_SDK_validate_function_list_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "validate_function_list failed: unknown result");
}

void Service_SDKClient::SetActivationState(const bool active)
{
  send_SetActivationState(active);
}

void Service_SDKClient::send_SetActivationState(const bool active)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetActivationState", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Service_SDK_SetActivationState_pargs args;
  args.active = &active;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void Service_SDKClient::NotifyServiceStarted()
{
  send_NotifyServiceStarted();
}

void Service_SDKClient::send_NotifyServiceStarted()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("NotifyServiceStarted", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Service_SDK_NotifyServiceStarted_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void Service_SDKClient::SendLegacyData(const std::string& dataJson)
{
  send_SendLegacyData(dataJson);
}

void Service_SDKClient::send_SendLegacyData(const std::string& dataJson)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SendLegacyData", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Service_SDK_SendLegacyData_pargs args;
  args.dataJson = &dataJson;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void Service_SDKClient::UpdateTrackedObjectMetadata(const std::vector< ::mixcast::data::TrackedObject> & trackedObjects)
{
  send_UpdateTrackedObjectMetadata(trackedObjects);
}

void Service_SDKClient::send_UpdateTrackedObjectMetadata(const std::vector< ::mixcast::data::TrackedObject> & trackedObjects)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("UpdateTrackedObjectMetadata", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Service_SDK_UpdateTrackedObjectMetadata_pargs args;
  args.trackedObjects = &trackedObjects;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void Service_SDKClient::UpdateCameraMetadata(const std::vector< ::mixcast::data::VirtualCamera> & cameras)
{
  send_UpdateCameraMetadata(cameras);
}

void Service_SDKClient::send_UpdateCameraMetadata(const std::vector< ::mixcast::data::VirtualCamera> & cameras)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("UpdateCameraMetadata", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Service_SDK_UpdateCameraMetadata_pargs args;
  args.cameras = &cameras;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void Service_SDKClient::UpdateViewfinderMetadata(const std::vector< ::mixcast::data::Viewfinder> & viewfinders)
{
  send_UpdateViewfinderMetadata(viewfinders);
}

void Service_SDKClient::send_UpdateViewfinderMetadata(const std::vector< ::mixcast::data::Viewfinder> & viewfinders)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("UpdateViewfinderMetadata", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Service_SDK_UpdateViewfinderMetadata_pargs args;
  args.viewfinders = &viewfinders;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void Service_SDKClient::UpdateDesktopMetadata(const  ::mixcast::data::Desktop& desktop)
{
  send_UpdateDesktopMetadata(desktop);
}

void Service_SDKClient::send_UpdateDesktopMetadata(const  ::mixcast::data::Desktop& desktop)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("UpdateDesktopMetadata", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Service_SDK_UpdateDesktopMetadata_pargs args;
  args.desktop = &desktop;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void Service_SDKClient::NotifyExternalTexturesUpdated(const std::vector< ::mixcast::thrift::SharedTexPacket> & textureInfo)
{
  send_NotifyExternalTexturesUpdated(textureInfo);
}

void Service_SDKClient::send_NotifyExternalTexturesUpdated(const std::vector< ::mixcast::thrift::SharedTexPacket> & textureInfo)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("NotifyExternalTexturesUpdated", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Service_SDK_NotifyExternalTexturesUpdated_pargs args;
  args.textureInfo = &textureInfo;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void Service_SDKClient::ResetWorldOrientation()
{
  send_ResetWorldOrientation();
}

void Service_SDKClient::send_ResetWorldOrientation()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("ResetWorldOrientation", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Service_SDK_ResetWorldOrientation_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void Service_SDKClient::ModifyWorldOrientation(const double degrees)
{
  send_ModifyWorldOrientation(degrees);
}

void Service_SDKClient::send_ModifyWorldOrientation(const double degrees)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("ModifyWorldOrientation", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Service_SDK_ModifyWorldOrientation_pargs args;
  args.degrees = &degrees;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void Service_SDKClient::SendExperienceCommand(const std::string& cmdId)
{
  send_SendExperienceCommand(cmdId);
}

void Service_SDKClient::send_SendExperienceCommand(const std::string& cmdId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SendExperienceCommand", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Service_SDK_SendExperienceCommand_pargs args;
  args.cmdId = &cmdId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

bool Service_SDKProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return true;
  }
  (this->*(pfn->second))(seqid, iprot, oprot, callContext);
  return true;
}

void Service_SDKProcessor::process_validate_ping(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("Service_SDK.validate_ping", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Service_SDK.validate_ping");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "Service_SDK.validate_ping");
  }

  Service_SDK_validate_ping_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "Service_SDK.validate_ping", bytes);
  }

  Service_SDK_validate_ping_result result;
  try {
    iface_->validate_ping();
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "Service_SDK.validate_ping");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("validate_ping", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "Service_SDK.validate_ping");
  }

  oprot->writeMessageBegin("validate_ping", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "Service_SDK.validate_ping", bytes);
  }
}

void Service_SDKProcessor::process_validate_function_list(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("Service_SDK.validate_function_list", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Service_SDK.validate_function_list");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "Service_SDK.validate_function_list");
  }

  Service_SDK_validate_function_list_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "Service_SDK.validate_function_list", bytes);
  }

  Service_SDK_validate_function_list_result result;
  try {
    iface_->validate_function_list(result.success);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "Service_SDK.validate_function_list");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("validate_function_list", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "Service_SDK.validate_function_list");
  }

  oprot->writeMessageBegin("validate_function_list", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "Service_SDK.validate_function_list", bytes);
  }
}

void Service_SDKProcessor::process_SetActivationState(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("Service_SDK.SetActivationState", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Service_SDK.SetActivationState");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "Service_SDK.SetActivationState");
  }

  Service_SDK_SetActivationState_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "Service_SDK.SetActivationState", bytes);
  }

  try {
    iface_->SetActivationState(args.active);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "Service_SDK.SetActivationState");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "Service_SDK.SetActivationState");
  }

  return;
}

void Service_SDKProcessor::process_NotifyServiceStarted(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("Service_SDK.NotifyServiceStarted", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Service_SDK.NotifyServiceStarted");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "Service_SDK.NotifyServiceStarted");
  }

  Service_SDK_NotifyServiceStarted_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "Service_SDK.NotifyServiceStarted", bytes);
  }

  try {
    iface_->NotifyServiceStarted();
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "Service_SDK.NotifyServiceStarted");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "Service_SDK.NotifyServiceStarted");
  }

  return;
}

void Service_SDKProcessor::process_SendLegacyData(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("Service_SDK.SendLegacyData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Service_SDK.SendLegacyData");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "Service_SDK.SendLegacyData");
  }

  Service_SDK_SendLegacyData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "Service_SDK.SendLegacyData", bytes);
  }

  try {
    iface_->SendLegacyData(args.dataJson);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "Service_SDK.SendLegacyData");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "Service_SDK.SendLegacyData");
  }

  return;
}

void Service_SDKProcessor::process_UpdateTrackedObjectMetadata(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("Service_SDK.UpdateTrackedObjectMetadata", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Service_SDK.UpdateTrackedObjectMetadata");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "Service_SDK.UpdateTrackedObjectMetadata");
  }

  Service_SDK_UpdateTrackedObjectMetadata_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "Service_SDK.UpdateTrackedObjectMetadata", bytes);
  }

  try {
    iface_->UpdateTrackedObjectMetadata(args.trackedObjects);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "Service_SDK.UpdateTrackedObjectMetadata");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "Service_SDK.UpdateTrackedObjectMetadata");
  }

  return;
}

void Service_SDKProcessor::process_UpdateCameraMetadata(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("Service_SDK.UpdateCameraMetadata", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Service_SDK.UpdateCameraMetadata");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "Service_SDK.UpdateCameraMetadata");
  }

  Service_SDK_UpdateCameraMetadata_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "Service_SDK.UpdateCameraMetadata", bytes);
  }

  try {
    iface_->UpdateCameraMetadata(args.cameras);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "Service_SDK.UpdateCameraMetadata");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "Service_SDK.UpdateCameraMetadata");
  }

  return;
}

void Service_SDKProcessor::process_UpdateViewfinderMetadata(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("Service_SDK.UpdateViewfinderMetadata", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Service_SDK.UpdateViewfinderMetadata");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "Service_SDK.UpdateViewfinderMetadata");
  }

  Service_SDK_UpdateViewfinderMetadata_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "Service_SDK.UpdateViewfinderMetadata", bytes);
  }

  try {
    iface_->UpdateViewfinderMetadata(args.viewfinders);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "Service_SDK.UpdateViewfinderMetadata");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "Service_SDK.UpdateViewfinderMetadata");
  }

  return;
}

void Service_SDKProcessor::process_UpdateDesktopMetadata(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("Service_SDK.UpdateDesktopMetadata", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Service_SDK.UpdateDesktopMetadata");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "Service_SDK.UpdateDesktopMetadata");
  }

  Service_SDK_UpdateDesktopMetadata_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "Service_SDK.UpdateDesktopMetadata", bytes);
  }

  try {
    iface_->UpdateDesktopMetadata(args.desktop);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "Service_SDK.UpdateDesktopMetadata");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "Service_SDK.UpdateDesktopMetadata");
  }

  return;
}

void Service_SDKProcessor::process_NotifyExternalTexturesUpdated(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("Service_SDK.NotifyExternalTexturesUpdated", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Service_SDK.NotifyExternalTexturesUpdated");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "Service_SDK.NotifyExternalTexturesUpdated");
  }

  Service_SDK_NotifyExternalTexturesUpdated_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "Service_SDK.NotifyExternalTexturesUpdated", bytes);
  }

  try {
    iface_->NotifyExternalTexturesUpdated(args.textureInfo);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "Service_SDK.NotifyExternalTexturesUpdated");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "Service_SDK.NotifyExternalTexturesUpdated");
  }

  return;
}

void Service_SDKProcessor::process_ResetWorldOrientation(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("Service_SDK.ResetWorldOrientation", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Service_SDK.ResetWorldOrientation");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "Service_SDK.ResetWorldOrientation");
  }

  Service_SDK_ResetWorldOrientation_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "Service_SDK.ResetWorldOrientation", bytes);
  }

  try {
    iface_->ResetWorldOrientation();
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "Service_SDK.ResetWorldOrientation");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "Service_SDK.ResetWorldOrientation");
  }

  return;
}

void Service_SDKProcessor::process_ModifyWorldOrientation(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("Service_SDK.ModifyWorldOrientation", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Service_SDK.ModifyWorldOrientation");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "Service_SDK.ModifyWorldOrientation");
  }

  Service_SDK_ModifyWorldOrientation_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "Service_SDK.ModifyWorldOrientation", bytes);
  }

  try {
    iface_->ModifyWorldOrientation(args.degrees);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "Service_SDK.ModifyWorldOrientation");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "Service_SDK.ModifyWorldOrientation");
  }

  return;
}

void Service_SDKProcessor::process_SendExperienceCommand(int32_t, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol*, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("Service_SDK.SendExperienceCommand", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "Service_SDK.SendExperienceCommand");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "Service_SDK.SendExperienceCommand");
  }

  Service_SDK_SendExperienceCommand_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "Service_SDK.SendExperienceCommand", bytes);
  }

  try {
    iface_->SendExperienceCommand(args.cmdId);
  } catch (const std::exception&) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "Service_SDK.SendExperienceCommand");
    }
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->asyncComplete(ctx, "Service_SDK.SendExperienceCommand");
  }

  return;
}

::apache::thrift::stdcxx::shared_ptr< ::apache::thrift::TProcessor > Service_SDKProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< Service_SDKIfFactory > cleanup(handlerFactory_);
  ::apache::thrift::stdcxx::shared_ptr< Service_SDKIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::apache::thrift::stdcxx::shared_ptr< ::apache::thrift::TProcessor > processor(new Service_SDKProcessor(handler));
  return processor;
}

void Service_SDKConcurrentClient::validate_ping()
{
  int32_t seqid = send_validate_ping();
  recv_validate_ping(seqid);
}

int32_t Service_SDKConcurrentClient::send_validate_ping()
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("validate_ping", ::apache::thrift::protocol::T_CALL, cseqid);

  Service_SDK_validate_ping_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void Service_SDKConcurrentClient::recv_validate_ping(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("validate_ping") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Service_SDK_validate_ping_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void Service_SDKConcurrentClient::validate_function_list(std::vector<std::string> & _return)
{
  int32_t seqid = send_validate_function_list();
  recv_validate_function_list(_return, seqid);
}

int32_t Service_SDKConcurrentClient::send_validate_function_list()
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("validate_function_list", ::apache::thrift::protocol::T_CALL, cseqid);

  Service_SDK_validate_function_list_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void Service_SDKConcurrentClient::recv_validate_function_list(std::vector<std::string> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("validate_function_list") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      Service_SDK_validate_function_list_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "validate_function_list failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void Service_SDKConcurrentClient::SetActivationState(const bool active)
{
  send_SetActivationState(active);
}

void Service_SDKConcurrentClient::send_SetActivationState(const bool active)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetActivationState", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Service_SDK_SetActivationState_pargs args;
  args.active = &active;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void Service_SDKConcurrentClient::NotifyServiceStarted()
{
  send_NotifyServiceStarted();
}

void Service_SDKConcurrentClient::send_NotifyServiceStarted()
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("NotifyServiceStarted", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Service_SDK_NotifyServiceStarted_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void Service_SDKConcurrentClient::SendLegacyData(const std::string& dataJson)
{
  send_SendLegacyData(dataJson);
}

void Service_SDKConcurrentClient::send_SendLegacyData(const std::string& dataJson)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SendLegacyData", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Service_SDK_SendLegacyData_pargs args;
  args.dataJson = &dataJson;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void Service_SDKConcurrentClient::UpdateTrackedObjectMetadata(const std::vector< ::mixcast::data::TrackedObject> & trackedObjects)
{
  send_UpdateTrackedObjectMetadata(trackedObjects);
}

void Service_SDKConcurrentClient::send_UpdateTrackedObjectMetadata(const std::vector< ::mixcast::data::TrackedObject> & trackedObjects)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("UpdateTrackedObjectMetadata", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Service_SDK_UpdateTrackedObjectMetadata_pargs args;
  args.trackedObjects = &trackedObjects;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void Service_SDKConcurrentClient::UpdateCameraMetadata(const std::vector< ::mixcast::data::VirtualCamera> & cameras)
{
  send_UpdateCameraMetadata(cameras);
}

void Service_SDKConcurrentClient::send_UpdateCameraMetadata(const std::vector< ::mixcast::data::VirtualCamera> & cameras)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("UpdateCameraMetadata", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Service_SDK_UpdateCameraMetadata_pargs args;
  args.cameras = &cameras;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void Service_SDKConcurrentClient::UpdateViewfinderMetadata(const std::vector< ::mixcast::data::Viewfinder> & viewfinders)
{
  send_UpdateViewfinderMetadata(viewfinders);
}

void Service_SDKConcurrentClient::send_UpdateViewfinderMetadata(const std::vector< ::mixcast::data::Viewfinder> & viewfinders)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("UpdateViewfinderMetadata", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Service_SDK_UpdateViewfinderMetadata_pargs args;
  args.viewfinders = &viewfinders;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void Service_SDKConcurrentClient::UpdateDesktopMetadata(const  ::mixcast::data::Desktop& desktop)
{
  send_UpdateDesktopMetadata(desktop);
}

void Service_SDKConcurrentClient::send_UpdateDesktopMetadata(const  ::mixcast::data::Desktop& desktop)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("UpdateDesktopMetadata", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Service_SDK_UpdateDesktopMetadata_pargs args;
  args.desktop = &desktop;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void Service_SDKConcurrentClient::NotifyExternalTexturesUpdated(const std::vector< ::mixcast::thrift::SharedTexPacket> & textureInfo)
{
  send_NotifyExternalTexturesUpdated(textureInfo);
}

void Service_SDKConcurrentClient::send_NotifyExternalTexturesUpdated(const std::vector< ::mixcast::thrift::SharedTexPacket> & textureInfo)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("NotifyExternalTexturesUpdated", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Service_SDK_NotifyExternalTexturesUpdated_pargs args;
  args.textureInfo = &textureInfo;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void Service_SDKConcurrentClient::ResetWorldOrientation()
{
  send_ResetWorldOrientation();
}

void Service_SDKConcurrentClient::send_ResetWorldOrientation()
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("ResetWorldOrientation", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Service_SDK_ResetWorldOrientation_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void Service_SDKConcurrentClient::ModifyWorldOrientation(const double degrees)
{
  send_ModifyWorldOrientation(degrees);
}

void Service_SDKConcurrentClient::send_ModifyWorldOrientation(const double degrees)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("ModifyWorldOrientation", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Service_SDK_ModifyWorldOrientation_pargs args;
  args.degrees = &degrees;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

void Service_SDKConcurrentClient::SendExperienceCommand(const std::string& cmdId)
{
  send_SendExperienceCommand(cmdId);
}

void Service_SDKConcurrentClient::send_SendExperienceCommand(const std::string& cmdId)
{
  int32_t cseqid = 0;
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SendExperienceCommand", ::apache::thrift::protocol::T_ONEWAY, cseqid);

  Service_SDK_SendExperienceCommand_pargs args;
  args.cmdId = &cmdId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
}

}} // namespace

